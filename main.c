#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "openssl_aes.h"
#include "tiny_aes.h"
#include "openluopworld_aes.h"

#include "openssl_des.h"
#include "rosetta_des.h"
#include "programmingalgorithms_des.h"

// how many times should the measurement be done
#define MEASUREMENT_RUNS 5

// Set to 0 for minimalistic output, set to 1 for more information.
#define RICH_OUTPUT 0

// values are in bytes
#define KEY_LENGTH 16
#define MESSAGE_LENGTH 64

// values are in bytes
#define DES_MSG_LEN_1 16
#define DES_MSG_LEN_2 64
#define DES_MSG_LEN_3 256

// values are in bytes
#define AES_MSG_LEN_1 16
#define AES_MSG_LEN_2 64
#define AES_MSG_LEN_3 256

#define AES_KEY_LEN 16

#define AES_OPENSSL_DEBUG 0

void separate_measurements() {
    if (RICH_OUTPUT) {
        printf("\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    }

    printf("\n");
}

void print_output(char* description, int runs, clock_t start, clock_t end, int msgLen) {
    msgLen = msgLen * 8;    // msgLen is in bits, turn to bytes
    double time_spent = ((double)end - (double)start) / CLOCKS_PER_SEC;
    double time_per_run = time_spent / runs;
    double bitrate = msgLen / time_per_run;
    bitrate *= 2; // run includes both encryption and decryption
    
    if (RICH_OUTPUT) {
        printf("\t%s \n\t\tTime elapsed: %f\n\t\tAverage time per run: %f\n\t\tBitrate: %.01lf b/s  =>  %.0lf B/s  =>  %.0lf kB/s\n\n",
            description, time_spent, time_spent / runs, bitrate, bitrate / 8, (bitrate / 8) / 100);
    }
    else {
        printf("%s bitrate kB/s: %.01f\n", description, (bitrate / 8) / 100);
    }
}

void measure_tiny_aes(int runs) {
    uint8_t iv[] = { 0x75, 0x52, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x21, 0x21 };
    uint8_t customKey[AES_KEY_LEN] = { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF };
    uint8_t message1[AES_MSG_LEN_1] = { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF };
    uint8_t message2[AES_MSG_LEN_2] = { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF };
    uint8_t message3[AES_MSG_LEN_3] = { 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF };
    
    clock_t start, end;
    start = clock();
    for (int i = 0; i < runs; i++) { tiny_aes(message1, customKey, iv, AES_MSG_LEN_1, AES_KEY_LEN); }
    end = clock();
    print_output("tiny AES - 128b", runs, start, end, AES_MSG_LEN_1);

    start = clock();
    for (int i = 0; i < runs; i++) { tiny_aes(message2, customKey, iv, AES_MSG_LEN_2, AES_KEY_LEN); }
    end = clock();
    print_output("tiny AES - 512b", runs, start, end, AES_MSG_LEN_2);

    start = clock();
    for (int i = 0; i < runs; i++) { tiny_aes(message3, customKey, iv, AES_MSG_LEN_3, AES_KEY_LEN); }
    end = clock();
    print_output("tiny AES - 2048b", runs, start, end, AES_MSG_LEN_3);
    separate_measurements();
}

void measure_openssl_aes(int runs) {
    clock_t start, end;
    unsigned char message1[AES_MSG_LEN_1] = { 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF };
    unsigned char message2[AES_MSG_LEN_2] = { 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF };
    unsigned char message3[AES_MSG_LEN_3] = { 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF };
    unsigned char iv[AES_BLOCK_SIZE];
    memset(iv, 0x00, AES_BLOCK_SIZE);
    unsigned char key[AES_KEY_LEN] = { 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF };
    int setEncryptKeySize = sizeof(key) * 8;

    int msg1Len = sizeof(message1);
    start = clock();
    for (int i = 0; i < runs; i++) {
        unsigned char enc_out[sizeof(message1)];
        unsigned char dec_out[sizeof(message1)];
        AES_KEY enc_key, dec_key;

        AES_set_encrypt_key(key, setEncryptKeySize, &enc_key);
        AES_cbc_encrypt(message1, enc_out, msg1Len, &enc_key, iv, AES_ENCRYPT);

        memset(iv, 0x00, AES_BLOCK_SIZE);   // need to reset IV
        AES_set_decrypt_key(key, setEncryptKeySize, &dec_key);
        AES_cbc_encrypt(enc_out, dec_out, msg1Len, &dec_key, iv, AES_DECRYPT);

        if (AES_OPENSSL_DEBUG) {
            print_data("\n Original", message1, msg1Len); // you can not print data as a string, because after Encryption its not ASCII
            print_data("\n Encrypted", enc_out, sizeof(enc_out));
            print_data("\n Decrypted", dec_out, sizeof(dec_out));
        }
    }
    end = clock();
    print_output("OpenSSL AES - 128b", runs, start, end, AES_MSG_LEN_1);

    int msg2Len = sizeof(message2);
    start = clock();
    for (int i = 0; i < runs; i++) {
        unsigned char enc_out[sizeof(message2)];
        unsigned char dec_out[sizeof(message2)];
        AES_KEY enc_key, dec_key;

        AES_set_encrypt_key(key, setEncryptKeySize, &enc_key);
        AES_cbc_encrypt(message2, enc_out, msg2Len, &enc_key, iv, AES_ENCRYPT);

        memset(iv, 0x00, AES_BLOCK_SIZE);   // need to reset IV
        AES_set_decrypt_key(key, setEncryptKeySize, &dec_key);
        AES_cbc_encrypt(enc_out, dec_out, msg2Len, &dec_key, iv, AES_DECRYPT);

        if (AES_OPENSSL_DEBUG) {
            print_data("\n Original", message2, msg2Len); // you can not print data as a string, because after Encryption its not ASCII
            print_data("\n Encrypted", enc_out, sizeof(enc_out));
            print_data("\n Decrypted", dec_out, sizeof(dec_out));
        }
    }
    end = clock();
    print_output("OpenSSL AES - 512b", runs, start, end, AES_MSG_LEN_2);

    int msg3Len = sizeof(message3);
    start = clock();
    for (int i = 0; i < runs; i++) {
        unsigned char enc_out[sizeof(message3)];
        unsigned char dec_out[sizeof(message3)];
        AES_KEY enc_key, dec_key;

        AES_set_encrypt_key(key, setEncryptKeySize, &enc_key);
        AES_cbc_encrypt(message3, enc_out, msg3Len, &enc_key, iv, AES_ENCRYPT);

        memset(iv, 0x00, AES_BLOCK_SIZE);   // need to reset IV
        AES_set_decrypt_key(key, setEncryptKeySize, &dec_key);
        AES_cbc_encrypt(enc_out, dec_out, msg3Len, &dec_key, iv, AES_DECRYPT);

        if (AES_OPENSSL_DEBUG) {
            print_data("\n Original", message3, msg3Len); // you can not print data as a string, because after Encryption its not ASCII
            print_data("\n Encrypted", enc_out, sizeof(enc_out));
            print_data("\n Decrypted", dec_out, sizeof(dec_out));
        }
    }
    end = clock();
    print_output("OpenSSL AES - 2048b", runs, start, end, AES_MSG_LEN_3);
    separate_measurements();
}

// Currently has no use, mainly for testing
void run_openluopworld_process() {
    uint8_t i, r;

    /* 128 bit key */
    uint8_t key[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,

    };

    uint8_t plaintext[] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    };

    uint8_t ciphertext[AES_BLOCK_SIZE];
    uint8_t roundkeys[AES_ROUND_KEY_SIZE];
    if (OPENLUOPWORLD_DEBUG) {
        printf("\n--------------------------------------------------------\n");
        printf("Plain text:\n");
        for (i = 0; i < AES_BLOCK_SIZE; i++) { printf("%2x ", plaintext[i]); }
    }

    aes_key_schedule_128(key, roundkeys);

    if (OPENLUOPWORLD_DEBUG) {
        printf("Round Keys:\n");
        for (r = 0; r <= AES_ROUNDS; r++) {
            for (i = 0; i < AES_BLOCK_SIZE; i++) {
                printf("%2x ", roundkeys[r * AES_BLOCK_SIZE + i]);
            }
            printf("\n");
        }
        printf("\n");
    }

    aes_encrypt_128(roundkeys, plaintext, ciphertext);

    if (OPENLUOPWORLD_DEBUG) {
        printf("Cipher text:\n");
        for (i = 0; i < AES_BLOCK_SIZE; i++) {
            printf("%2x ", ciphertext[i]);
        }
    }

    aes_decrypt_128(roundkeys, ciphertext, ciphertext);

    if (OPENLUOPWORLD_DEBUG) {
        printf("Plain text:\n");
        for (i = 0; i < AES_BLOCK_SIZE; i++) {
            printf("%2x ", ciphertext[i]);
        }
        for (i = 0; i < AES_BLOCK_SIZE; i++) {
            if (ciphertext[i] != plaintext[i]) { break; }
        }
        if (AES_BLOCK_SIZE != i) { printf("\nDECRYPT WRONG\n\n"); }
        else {
            printf("\nDECRYPT CORRECT\n\n");
        }
    }
}

void measure_openluopworld_aes(int runs) {
    uint8_t key[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,

    };

    uint8_t plaintext[] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    };

    uint8_t ciphertext[AES_BLOCK_SIZE];
    uint8_t roundkeys[AES_ROUND_KEY_SIZE];

    clock_t start, end;
    start = clock();
    aes_key_schedule_128(key, roundkeys);
    for (int i = 0; i < runs; i++) {
        aes_encrypt_128(roundkeys, plaintext, ciphertext);
        aes_decrypt_128(roundkeys, ciphertext, ciphertext);
    }
    end = clock();
    print_output("Openluopworld - AES 128b", runs, start, end, AES_MSG_LEN_1);

    start = clock();
    aes_key_schedule_128(key, roundkeys);
    for (int i = 0; i < runs; i++) {
        for (int j = 0; j < 4; j++) {
            aes_encrypt_128(roundkeys, plaintext, ciphertext);
            aes_decrypt_128(roundkeys, ciphertext, ciphertext);
        }
    }
    end = clock();
    print_output("Openluopworld - AES 512b", runs, start, end, AES_MSG_LEN_2);

    start = clock();
    aes_key_schedule_128(key, roundkeys);
    for (int i = 0; i < runs; i++) {
        for (int j = 0; j < 16; j++) {
            aes_encrypt_128(roundkeys, plaintext, ciphertext);
            aes_decrypt_128(roundkeys, ciphertext, ciphertext);
        }
    }
    end = clock();
    print_output("Openluopworld - AES 2048b", runs, start, end, AES_MSG_LEN_3);

    separate_measurements();
}

void measure_rosetta_des(int runs) {
    clock_t start, end;
    ubyte message1[DES_MSG_LEN_1] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    ubyte message2[DES_MSG_LEN_2] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    ubyte message3[DES_MSG_LEN_3] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };

    start = clock();
    for (int i = 0; i < runs; i++) { rosetta_main(message1, DES_MSG_LEN_1); }
    end = clock();
    print_output("rosetta DES - 128b", runs, start, end, DES_MSG_LEN_1);

    start = clock();
    for (int i = 0; i < runs; i++) { rosetta_main(message2, DES_MSG_LEN_2); }
    end = clock();
    print_output("rosetta DES - 512b", runs, start, end, DES_MSG_LEN_2);

    start = clock();
    for (int i = 0; i < runs; i++) { rosetta_main(message3, DES_MSG_LEN_3); }
    end = clock();
    print_output("rosetta DES - 2048b", runs, start, end, DES_MSG_LEN_3);
    separate_measurements();
}

void measure_programmingalgorithms_des(int runs) {
    clock_t start, end;
    uint8_t message1[DES_MSG_LEN_1] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    uint8_t message2[DES_MSG_LEN_2] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    uint8_t message3[DES_MSG_LEN_3] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };

    uint8_t out1[DES_MSG_LEN_1];
    start = clock();
    for (int i = 0; i < runs; i++) { programmingalrorithms_des(message1, out1); }
    end = clock();
    print_output("programmingalgorithms DES - 128b", runs, start, end, DES_MSG_LEN_1);

    uint8_t out2[DES_MSG_LEN_2];
    start = clock();
    for (int i = 0; i < runs; i++) { programmingalrorithms_des(message2, out2); }
    end = clock();
    print_output("programmingalgorithms DES - 512b", runs, start, end, DES_MSG_LEN_2);

    uint8_t out3[DES_MSG_LEN_3];
    start = clock();
    for (int i = 0; i < runs; i++) { programmingalrorithms_des(message3, out3); }
    end = clock();
    print_output("programmingalgorithms DES - 2048b", runs, start, end, DES_MSG_LEN_3);
    separate_measurements();
}

void measure_openssl_des(int runs) {
    clock_t start, end;
    unsigned char message1[DES_MSG_LEN_1] = "Vstup s 16 znaky";
    unsigned char message2[DES_MSG_LEN_2] = "Vstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znaky";
    unsigned char message3[DES_MSG_LEN_3] = "Vstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znakyVstup s 16 znaky";

    start = clock();
    for (int i = 0; i < runs; i++) { openssl_des_main(message1, DES_MSG_LEN_1); }
    end = clock();
    print_output("OpenSSL DES - 128b", runs, start, end, DES_MSG_LEN_1);

    start = clock();
    for (int i = 0; i < runs; i++) { openssl_des_main(message2, DES_MSG_LEN_2); }
    end = clock();
    print_output("OpenSSL DES - 512b", runs, start, end, DES_MSG_LEN_2);

    start = clock();
    for (int i = 0; i < runs; i++) { openssl_des_main(message3, DES_MSG_LEN_3); }
    end = clock();
    print_output("OpenSSL DES - 2048b", runs, start, end, DES_MSG_LEN_3);
    separate_measurements();
}

void measure_aes(int runs) {
    printf("\nADVANCED ENCRYPTION STANDARD MEASUREMENT RESULTS:\n");
    for (int i = 0; i < MEASUREMENT_RUNS; i++) {
        measure_openluopworld_aes(runs);
        //measure_openssl_aes(runs);
        //measure_tiny_aes(runs);
    }
}

void measure_des(int runs) {
    printf("\nDATA ENCRYPTION STANDARD MEASUREMENT RESULTS:\n");
    for (int i = 0; i < MEASUREMENT_RUNS; i++) {
        measure_openssl_des(runs);
        measure_programmingalgorithms_des(runs);
        measure_rosetta_des(runs);
    }
}

int main() {
    int encryption_runs = 50000;
    printf("Ecryption will happen in %i rounds. In one round there will be runs: %i\n", MEASUREMENT_RUNS, encryption_runs);
    measure_aes(encryption_runs);
    // measure_des(encryption_runs);
    printf("Measurement done! Exiting...\n");
    return 0;
}
